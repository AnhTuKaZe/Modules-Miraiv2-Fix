const moment = require('moment-timezone');
const fs = require('fs');
module.exports.config = {
	name: "message", // T√™n l·ªánh, ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vi·ªác g·ªçi l·ªánh
	version: "beta", // phi√™n b·∫£n c·ªßa module n√†y
	hasPermssion: 0, // Quy·ªÅn h·∫°n s·ª≠ d·ª•ng, v·ªõi 0 l√† to√†n b·ªô th√†nh vi√™n, 1 l√† qu·∫£n tr·ªã vi√™n tr·ªü l√™n, 2 l√† admin/owner
	credits: "chom", // C√¥ng nh·∫≠n module s·ªü h·ªØu l√† ai
	description: "JUST CHECKTT", // Th√¥ng tin chi ti·∫øt v·ªÅ l·ªánh
	commandCategory: "group", // Thu·ªôc v√†o nh√≥m n√†o: system, other, game-sp, game-mp, random-img, edit-img, media, economy, ...
	usages: "[all]", // C√°ch s·ª≠ d·ª•ng l·ªánh
	cooldowns: 5, // Th·ªùi gian m·ªôt ng∆∞·ªùi c√≥ th·ªÉ l·∫∑p l·∫°i l·ªánh
};

const monthToMSObj = {
	1: 31 * 24 * 60 * 60 * 1000,
	2: 28 * 24 * 60 * 60 * 1000,
	3: 31 * 24 * 60 * 60 * 1000,
	4: 30 * 24 * 60 * 60 * 1000,
	5: 31 * 24 * 60 * 60 * 1000,
	6: 30 * 24 * 60 * 60 * 1000,
	7: 31 * 24 * 60 * 60 * 1000,
	8: 31 * 24 * 60 * 60 * 1000,
	9: 30 * 24 * 60 * 60 * 1000,
	10: 31 * 24 * 60 * 60 * 1000,
	11: 30 * 24 * 60 * 60 * 1000,
	12: 31 * 24 * 60 * 60 * 1000
}


//FUNCTION HO·∫†T ƒê·ªòNG NH∆Ø C√ÅI T√äN C·ª¶A N√ì
const checkTime = (time) => new Promise((resolve) => {
	time.forEach((e, i) => time[i] = parseInt(String(e).trim()));
	const getDayFromMonth = (month) => (month == 0) ? 0 : (month == 2) ? (time[2] % 4 == 0) ? 29 : 28 : ([1, 3, 5, 7, 8, 10, 12].includes(month)) ? 31 : 30;
	yr = time[2] - 1970;
	yearToMS = (yr) * 365 * 24 * 60 * 60 * 1000;
	yearToMS += ((yr - 2) / 4).toFixed(0) * 24 * 60 * 60 * 1000;
	monthToMS = 0;
	for (let i = 1; i < time[1]; i++) monthToMS += monthToMSObj[i];
	if (time[2] % 4 == 0) monthToMS += 24 * 60 * 60 * 1000;
	dayToMS = time[0] * 24 * 60 * 60 * 1000;
	hourToMS = time[3] * 60 * 60 * 1000;
	minuteToMS = time[4] * 60 * 1000;
	secondToMS = time[5] * 1000;
	oneDayToMS = 24 * 60 * 60 * 1000;
	timeMs = yearToMS + monthToMS + dayToMS + hourToMS + minuteToMS + secondToMS - oneDayToMS;
	resolve(timeMs);
});

const tt = (yesterDay, toDay, time) => new Promise((resolve) => {
	if(yesterDay == 0) resolve("ch∆∞a c√≥ s·ªë li·ªáu th·ªëng k√™");
	if(toDay == 0) resolve("ch∆∞a c√≥ s·ªë li·ªáu th·ªëng k√™");
	let hqua = yesterDay % 24;
	let hnay = toDay % time;
	let kqua = hqua % hnay * 100;
	resolve(kqua.toFixed(2) + "%");
});

module.exports.handleEvent = async ({ api, event, args, handleEvent }) => {
    const { threadID, messageID, senderID } = event;
	const path = __dirname + '/cache/checkttDay.json';
	if(!fs.existsSync(path)) fs.writeFileSync(path, JSON.stringify({}));
	let data = JSON.parse(fs.readFileSync(path));
	var timeVN = moment().tz('Asia/Ho_Chi_Minh').format('DD_MM_YYYY_HH_mm_ss');
	var time = timeVN.split("_");
	var time1 = await checkTime(time);
	var time2 = await new Date(time1)
	var time3 = time2.getDay();
	if(!data[threadID]) data[threadID] = {};
	if(!data[threadID][time3]) data[threadID][time3] = {};
	if(!data[threadID][time3].user) data[threadID][time3].user = {};
	if(!data[threadID][time3].user[senderID]) data[threadID][time3].user[senderID] = {yesterDay: 0, today: 0, weekday: 0};
	if(data[threadID][time3 - 1]) {
		for(let i in data[threadID][time3 - 1].user) {
			if(!data[threadID][time3].user[i]) data[threadID][time3].user[i] = {yesterDay: 0, today: 0, weekday: 0};
			data[threadID][time3].user[i].yesterDay = data[threadID][time3 - 1].user[i].today;
			data[threadID][time3].user[i].weekday = data[threadID][time3 - 1].user[i].weekday;
		}
		data[threadID][time3 - 1] = {};
	} else if(data[threadID][time3 + 6]) {
		for(let i in data[threadID][time3 + 6].user) {
			if(!data[threadID][time3].user[i]) data[threadID][time3].user[i] = {yesterDay: 0, today: 0, weekday: 0};
			data[threadID][time3].user[i].yesterDay = data[threadID][time3 + 6].user[i].today;
			data[threadID][time3].user[i].weekday = data[threadID][time3 + 6].user[i].weekday;
		}
		data[threadID][time3 + 6] = {};
	}
	if(time3 - 1 == 0) {
		for(let i in data[threadID][time3].user) {
			data[threadID][time3].user[i].weekday = 0;
		}
	}
	let toDay = data[threadID][time3].user[senderID].today;
	let weekDay = data[threadID][time3].user[senderID].weekday;
	toDay += 1;
	weekDay += 1;
	data[threadID][time3].user[senderID].today = toDay;
	data[threadID][time3].user[senderID].weekday = weekDay;
	fs.writeFileSync(path, JSON.stringify(data, null, 4));
}

module.exports.run = async ({ api, event, args, Currencies, Users }) => {
	const { threadID, messageID, senderID } = event;
	const path = __dirname + '/cache/checkttDay.json';
	if(!fs.existsSync(path)) fs.writeFileSync(path, JSON.stringify({}));
	let data = JSON.parse(fs.readFileSync(path));
	var timeVN = moment().tz('Asia/Ho_Chi_Minh').format('DD_MM_YYYY_HH_mm_ss');
	var time = timeVN.split("_");
	var time1 = await checkTime(time);
	var time2 = await new Date(time1)
	var time3 = time2.getDay();
	let mention = Object.keys(event.mentions)
	if(args[0] == "all") {
		var storage = [], exp = [];
		for(let i in data[threadID][time3].user) storage.push({"name": await Users.getNameUser(i), "exp": data[threadID][time3].user[i].weekday});
		storage.sort(function (a, b) { return b.exp - a.exp });
		let msg = "==„ÄåKI·ªÇM TRA T∆Ø∆†NG T√ÅC„Äç==\n";
		msg += `\nüë§: Ng∆∞·ªùi d·∫´n ƒë·∫ßu l√†: ${storage[0].name} v·ªõi ${storage[0].exp} tin nh·∫Øn`;
		for(let i = 1; i < storage.length; i++) {
			msg += `\n${i+1}. ${storage[i].name}: ${storage[i].exp} tin nh·∫Øn`;
		}
		let sum = 0;
		for(let i in data[threadID][time3].user) {
			sum += data[threadID][time3].user[i].weekday;
		} 
		msg += `\n¬ª T·ªïng s·ªë tin nh·∫Øn c·ªßa box trong tu·∫ßn qua: ${sum}`;
		return api.sendMessage(msg, threadID);
	} else if(mention[0]) {
		let idUser = mention[0];
		let nameUser = await Users.getNameUser(idUser);
		const yesterDay = data[threadID][time3].user[idUser].yesterDay;
		const today = data[threadID][time3].user[idUser].today;
		const weekDay = data[threadID][time3].user[idUser].weekday;
		var storage = [], exp = [];
		const dataThread = await api.getThreadInfo(event.threadID);
		for (const value of dataThread.userInfo) storage.push({"id" : value.id, "name": value.name});
		for (const user of storage) {
			const countMess = await Currencies.getData(user.id);
			exp.push({"name" : user.name, "exp": (typeof countMess.exp == "undefined") ? 0 : countMess.exp, "uid": user.id});
		}
		exp.sort(function (a, b) { return b.exp - a.exp });
		const rank = exp.findIndex(e => parseInt(e.uid) == parseInt(mention[0])) + 1;
		const infoUser = exp[rank - 1];
		let msg, test = await tt(yesterDay, today, time[3]);
		if(isNaN(test)) {
			msg = "th·ªëng k√™ ch∆∞a r√µ r√†ng";
		} else {
			msg = await tt(yesterDay, today, time[3]);
		}
		return api.sendMessage(`=== ${nameUser} ===\nüôÜ‚Äç‚ôÇÔ∏è t·ªïng s·ªë tin nh·∫Øn: ${infoUser.exp}\nüê∏ M·ª©c ƒë·ªô t∆∞∆°ng t√°c: ${msg}\n‚è±Ô∏è T·ªïng s·ªë tin nh·∫Øn h√¥m qua: ${yesterDay}\n‚è∞ T·ªïng s·ªë tin nh·∫Øn h√¥m nay: ${today}\nüñ§ T·ªïng s·ªë tin nh·∫Øn trong tu·∫ßn: ${weekDay}`, threadID, messageID);
	} else {const moment = require('moment-timezone');
const fs = require('fs');
module.exports.config = {
	name: "message", // T√™n l·ªánh, ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vi·ªác g·ªçi l·ªánh
	version: "beta", // phi√™n b·∫£n c·ªßa module n√†y
	hasPermssion: 0, // Quy·ªÅn h·∫°n s·ª≠ d·ª•ng, v·ªõi 0 l√† to√†n b·ªô th√†nh vi√™n, 1 l√† qu·∫£n tr·ªã vi√™n tr·ªü l√™n, 2 l√† admin/owner
	credits: "TruongMini + Adonis", // C√¥ng nh·∫≠n module s·ªü h·ªØu l√† ai
	description: "JUST CHECKTT", // Th√¥ng tin chi ti·∫øt v·ªÅ l·ªánh
	commandCategory: "D√†nh cho ng∆∞·ªùi d√πng", // Thu·ªôc v√†o nh√≥m n√†o: system, other, game-sp, game-mp, random-img, edit-img, media, economy, ...
	usages: "[all]", // C√°ch s·ª≠ d·ª•ng l·ªánh
	cooldowns: 5, // Th·ªùi gian m·ªôt ng∆∞·ªùi c√≥ th·ªÉ l·∫∑p l·∫°i l·ªánh
};

const monthToMSObj = {
	1: 31 * 24 * 60 * 60 * 1000,
	2: 28 * 24 * 60 * 60 * 1000,
	3: 31 * 24 * 60 * 60 * 1000,
	4: 30 * 24 * 60 * 60 * 1000,
	5: 31 * 24 * 60 * 60 * 1000,
	6: 30 * 24 * 60 * 60 * 1000,
	7: 31 * 24 * 60 * 60 * 1000,
	8: 31 * 24 * 60 * 60 * 1000,
	9: 30 * 24 * 60 * 60 * 1000,
	10: 31 * 24 * 60 * 60 * 1000,
	11: 30 * 24 * 60 * 60 * 1000,
	12: 31 * 24 * 60 * 60 * 1000
}


//FUNCTION HO·∫†T ƒê·ªòNG NH∆Ø C√ÅI T√äN C·ª¶A N√ì
const checkTime = (time) => new Promise((resolve) => {
	time.forEach((e, i) => time[i] = parseInt(String(e).trim()));
	const getDayFromMonth = (month) => (month == 0) ? 0 : (month == 2) ? (time[2] % 4 == 0) ? 29 : 28 : ([1, 3, 5, 7, 8, 10, 12].includes(month)) ? 31 : 30;
	yr = time[2] - 1970;
	yearToMS = (yr) * 365 * 24 * 60 * 60 * 1000;
	yearToMS += ((yr - 2) / 4).toFixed(0) * 24 * 60 * 60 * 1000;
	monthToMS = 0;
	for (let i = 1; i < time[1]; i++) monthToMS += monthToMSObj[i];
	if (time[2] % 4 == 0) monthToMS += 24 * 60 * 60 * 1000;
	dayToMS = time[0] * 24 * 60 * 60 * 1000;
	hourToMS = time[3] * 60 * 60 * 1000;
	minuteToMS = time[4] * 60 * 1000;
	secondToMS = time[5] * 1000;
	oneDayToMS = 24 * 60 * 60 * 1000;
	timeMs = yearToMS + monthToMS + dayToMS + hourToMS + minuteToMS + secondToMS - oneDayToMS;
	resolve(timeMs);
});

const tt = (yesterDay, toDay, time) => new Promise((resolve) => {
	if(yesterDay == 0) resolve("ch∆∞a c√≥ s·ªë li·ªáu th·ªëng k√™");
	if(toDay == 0) resolve("ch∆∞a c√≥ s·ªë li·ªáu th·ªëng k√™");
	let hqua = yesterDay % 24;
	let hnay = toDay % time;
	let kqua = hqua % hnay * 100;
	resolve(kqua.toFixed(2) + "%");
});

module.exports.handleEvent = async ({ api, event, args, handleEvent }) => {
    const { threadID, messageID, senderID } = event;
	const path = __dirname + '/cache/checkttDay.json';
	if(!fs.existsSync(path)) fs.writeFileSync(path, JSON.stringify({}));
	let data = JSON.parse(fs.readFileSync(path));
	var timeVN = moment().tz('Asia/Ho_Chi_Minh').format('DD_MM_YYYY_HH_mm_ss');
	var time = timeVN.split("_");
	var time1 = await checkTime(time);
	var time2 = await new Date(time1)
	var time3 = time2.getDay();
	if(!data[threadID]) data[threadID] = {};
	if(!data[threadID][time3]) data[threadID][time3] = {};
	if(!data[threadID][time3].user) data[threadID][time3].user = {};
	if(!data[threadID][time3].user[senderID]) data[threadID][time3].user[senderID] = {yesterDay: 0, today: 0, weekday: 0};
	if(data[threadID][time3 - 1]) {
		for(let i in data[threadID][time3 - 1].user) {
			if(!data[threadID][time3].user[i]) data[threadID][time3].user[i] = {yesterDay: 0, today: 0, weekday: 0};
			data[threadID][time3].user[i].yesterDay = data[threadID][time3 - 1].user[i].today;
			data[threadID][time3].user[i].weekday = data[threadID][time3 - 1].user[i].weekday;
		}
		data[threadID][time3 - 1] = {};
	} else if(data[threadID][time3 + 6]) {
		for(let i in data[threadID][time3 + 6].user) {
			if(!data[threadID][time3].user[i]) data[threadID][time3].user[i] = {yesterDay: 0, today: 0, weekday: 0};
			data[threadID][time3].user[i].yesterDay = data[threadID][time3 + 6].user[i].today;
			data[threadID][time3].user[i].weekday = data[threadID][time3 + 6].user[i].weekday;
		}
		data[threadID][time3 + 6] = {};
	}
	if(time3 - 1 == 0) {
		for(let i in data[threadID][time3].user) {
			data[threadID][time3].user[i].weekday = 0;
		}
	}
	let toDay = data[threadID][time3].user[senderID].today;
	let weekDay = data[threadID][time3].user[senderID].weekday;
	toDay += 1;
	weekDay += 1;
	data[threadID][time3].user[senderID].today = toDay;
	data[threadID][time3].user[senderID].weekday = weekDay;
	fs.writeFileSync(path, JSON.stringify(data, null, 4));
}

module.exports.run = async ({ api, event, args, Currencies, Users }) => {
	const { threadID, messageID, senderID } = event;
	const path = __dirname + '/cache/checkttDay.json';
	if(!fs.existsSync(path)) fs.writeFileSync(path, JSON.stringify({}));
	let data = JSON.parse(fs.readFileSync(path));
	var timeVN = moment().tz('Asia/Ho_Chi_Minh').format('DD_MM_YYYY_HH_mm_ss');
	var time = timeVN.split("_");
	var time1 = await checkTime(time);
	var time2 = await new Date(time1)
	var time3 = time2.getDay();
	let mention = Object.keys(event.mentions)
	if(args[0] == "all") {
		var storage = [], exp = [];
		for(let i in data[threadID][time3].user) storage.push({"name": await Users.getNameUser(i), "exp": data[threadID][time3].user[i].weekday});
		storage.sort(function (a, b) { return b.exp - a.exp });
		let msg = "==„ÄåKI·ªÇM TRA T∆Ø∆†NG T√ÅC„Äç==\n";
		msg += `\nüë§: Ng∆∞·ªùi d·∫´n ƒë·∫ßu l√†: ${storage[0].name} v·ªõi ${storage[0].exp} tin nh·∫Øn`;
		for(let i = 1; i < storage.length; i++) {
			msg += `\n${i+1}. ${storage[i].name}: ${storage[i].exp} tin nh·∫Øn`;
		}
		let sum = 0;
		for(let i in data[threadID][time3].user) {
			sum += data[threadID][time3].user[i].weekday;
		} 
		msg += `\n¬ª T·ªïng s·ªë tin nh·∫Øn c·ªßa box trong tu·∫ßn qua: ${sum}`;
		return api.sendMessage(msg, threadID);
	} else if(mention[0]) {
		let idUser = mention[0];
		let nameUser = await Users.getNameUser(idUser);
		const yesterDay = data[threadID][time3].user[idUser].yesterDay;
		const today = data[threadID][time3].user[idUser].today;
		const weekDay = data[threadID][time3].user[idUser].weekday;
		var storage = [], exp = [];
		const dataThread = await api.getThreadInfo(event.threadID);
		for (const value of dataThread.userInfo) storage.push({"id" : value.id, "name": value.name});
		for (const user of storage) {
			const countMess = await Currencies.getData(user.id);
			exp.push({"name" : user.name, "exp": (typeof countMess.exp == "undefined") ? 0 : countMess.exp, "uid": user.id});
		}
		exp.sort(function (a, b) { return b.exp - a.exp });
		const rank = exp.findIndex(e => parseInt(e.uid) == parseInt(mention[0])) + 1;
		const infoUser = exp[rank - 1];
		let msg, test = await tt(yesterDay, today, time[3]);
		if(isNaN(test)) {
			msg = "th·ªëng k√™ ch∆∞a r√µ r√†ng";
		} else {
			msg = await tt(yesterDay, today, time[3]);
		}
		return api.sendMessage(`=== ${nameUser} ===\nüôÜ‚Äç‚ôÇÔ∏è t·ªïng s·ªë tin nh·∫Øn: ${infoUser.exp}\nüê∏ M·ª©c ƒë·ªô t∆∞∆°ng t√°c: ${msg}\n‚è±Ô∏è T·ªïng s·ªë tin nh·∫Øn h√¥m qua: ${yesterDay}\n‚è∞ T·ªïng s·ªë tin nh·∫Øn h√¥m nay: ${today}\nüñ§ T·ªïng s·ªë tin nh·∫Øn trong tu·∫ßn: ${weekDay}`, threadID, messageID);
	} else {
		const countMess = await Currencies.getData(senderID);
		const yesterDay = data[threadID][time3].user[senderID].yesterDay;
		const today = data[threadID][time3].user[senderID].today;
		const weekDay = data[threadID][time3].user[senderID].weekday;
		let nameUser = await Users.getNameUser(senderID);
		let sum = 0;
		let msg, test = await tt(yesterDay, today, time[3]);
		if(isNaN(test)) {
			msg = "th·ªëng k√™ ch∆∞a r√µ r√†ng";
		} else {
			msg = await tt(yesterDay, today, time[3]);
		}
		return api.sendMessage(`=== ${nameUser} ===\nüôÜ‚Äç‚ôÇÔ∏è t·ªïng s·ªë tin nh·∫Øn: ${(typeof countMess.exp == "undefined") ? 0 : countMess.exp}\nüê∏ M·ª©c ƒë·ªô t∆∞∆°ng t√°c: ${msg}\n‚è±Ô∏è T·ªïng s·ªë tin nh·∫Øn h√¥m qua: ${yesterDay}\n‚è∞ T·ªïng s·ªë tin nh·∫Øn h√¥m nay: ${today}\nüñ§ T·ªïng s·ªë tin nh·∫Øn trong tu·∫ßn: ${weekDay}`, threadID, messageID);
	}
}
		const countMess = await Currencies.getData(senderID);
		const yesterDay = data[threadID][time3].user[senderID].yesterDay;
		const today = data[threadID][time3].user[senderID].today;
		const weekDay = data[threadID][time3].user[senderID].weekday;
		let nameUser = await Users.getNameUser(senderID);
		let sum = 0;
		let msg, test = await tt(yesterDay, today, time[3]);
		if(isNaN(test)) {
			msg = "th·ªëng k√™ ch∆∞a r√µ r√†ng";
		} else {
			msg = await tt(yesterDay, today, time[3]);
		}
		return api.sendMessage(`=== ${nameUser} ===\nüôÜ‚Äç‚ôÇÔ∏è t·ªïng s·ªë tin nh·∫Øn: ${(typeof countMess.exp == "undefined") ? 0 : countMess.exp}\nüê∏ M·ª©c ƒë·ªô t∆∞∆°ng t√°c: ${msg}\n‚è±Ô∏è T·ªïng s·ªë tin nh·∫Øn h√¥m qua: ${yesterDay}\n‚è∞ T·ªïng s·ªë tin nh·∫Øn h√¥m nay: ${today}\nüñ§ T·ªïng s·ªë tin nh·∫Øn trong tu·∫ßn: ${weekDay}`, threadID, messageID);
	}
}